// ==========================
// Qt includes
// ==========================

#include "mainwindow.h"            // MainWindow class declaration
#include "memoryitem.h"           // Fragment / MemoryItem inheritance
#include "./ui_mainwindow.h"       // UI elements generated by Qt Designer

#include <QMessageBox>             // Popup alerts (warning, info, error)
#include <QNetworkAccessManager>   // Sends OpenAI API + Google TTS requests
#include <QNetworkRequest>         // Builds request headers and URLs
#include <QNetworkReply>           // Receives and handles network responses

#include <QJsonDocument>           // Parses and creates JSON documents
#include <QJsonObject>             // Handles JSON objects
#include <QJsonArray>              // Handles JSON arrays

#include <QTableWidget>            // Table for Spanish/English element rows
#include <QHeaderView>             // Column resizing and header styling

#include <QTextEdit>               // Spanish and English text cells
#include <QPushButton>             // Buttons (Add, Submit, Delete, Audio, etc.)

#include <QStandardPaths>          // Finds AppData and temp directories
#include <QDir>                    // Creates dirs, lists book files
#include <QFile>                   // Reads/writes JSON files and audio temp file

#include <QColor>                  // Background colors for correctness highlighting

#include <QAbstractScrollArea>     // Used indirectly by widgets

#include <QTextOption>             // Controls word wrapping in QTextEdits

#include <algorithm>               // std::sort for fixing row order after drag/drop

#include <QRandomGenerator>        // Not used anywhere ‚Üí can be removed

#include <QInputDialog>            // Dialog for naming new books
#include <QLineEdit>               // Text input inside QInputDialog
#include <QFileDialog>             // Lets user choose book file (.txt or .json)


// -----------------------------------------------------------
// Table column index constants
// -----------------------------------------------------------
// These define which column of the QTableWidget corresponds to
// Spanish text, English text, the delete button, and the audio button.
// They prevent the use of ‚Äúmagic numbers‚Äù (0, 1, 2, 3) throughout
// the code, making the logic clearer and less error-prone.
//
// They are `constexpr` so the values are compile-time constants,
// and `static` so they are visible only within this .cpp file.
// -----------------------------------------------------------

static constexpr int COL_ES     = 0;
static constexpr int COL_EN     = 1;
static constexpr int COL_DELETE = 2;
static constexpr int COL_AUDIO = 3;

// -----------------------------------------------------------
// Global state for practice mode
// -----------------------------------------------------------

//
// englishToSpanishMode:
//   Tracks whether the user is practicing English‚ÜíSpanish (true)
//   or Spanish‚ÜíEnglish (false). Many parts of the program behave
//   differently depending on this mode (AI prompt, validation,
//   table display, rebuilding sentences, etc.).
//   Declared static to keep the flag local to this file.
// -----------------------------------------------------------

static bool englishToSpanishMode = false;

// -----------------------------------------------------------
// MEMORY SYSTEM ‚Äî where saved word fragments are stored,
// loaded, searched, and updated.
// -----------------------------------------------------------
//
// memoryFilePath()
//   Figures out where the app should store sentence_memory.json.
//   Creates the directory if it doesn't exist.
//
// loadMemory()
//   Reads sentence_memory.json from disk (if it exists),
//   parses the JSON, and loads all saved Spanish‚ÜíEnglish
//   fragments into the global array g_memory.
//
// saveMemory()
//   Converts g_memory back into JSON and writes it to
//   sentence_memory.json so the user's progress persists.
//
// isKnownSpanish(es)
//   Checks if a given Spanish fragment already exists in memory.
//   Used to decide whether English should be hidden or shown.
//
// lookupEnglish(es)
//   Returns the saved English translation for a Spanish fragment,
//   or an empty string if not found.
//
// addToMemory(es, en)
//   Saves a Spanish‚ÜíEnglish pair:
//     ‚Ä¢ Updates the existing entry if Spanish already exists.
//     ‚Ä¢ Otherwise appends a new entry.
//   Called when the user submits answers or learns new fragments.
//
// Together, these functions form the full persistence layer
// for vocabulary: loading it at startup, checking it during practice,
// and saving updates whenever the user learns new elements.
// -----------------------------------------------------------
static QJsonArray g_memory;
// g_memory:
//   Stores all saved Spanish‚ÜíEnglish fragments the user has learned.
//   Used by lookup, validation, random sentence generation, and saving.
//   Declared static so it is private to this .cpp file.
// ==========================
// Determines where sentence_memory.json is stored.
// ==========================
// Tracks last 100 correctness results (true/false)
static QVector<bool> g_history;

static QString memoryFilePath()
{
    QString dir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    if (dir.isEmpty())
        dir = QDir::homePath() + "/.LangLearnApp";

    QDir().mkpath(dir);
    return dir + "/sentence_memory.json";
}

// ==========================
// Loads saved pairs from disk into g_memory.
// ==========================
static void loadMemory()
{
    g_memory = QJsonArray();

    QFile f(memoryFilePath());
    if (!f.exists()) return;
    if (!f.open(QIODevice::ReadOnly)) return;

    QJsonDocument doc = QJsonDocument::fromJson(f.readAll());
    if (doc.isArray())
        g_memory = doc.array();
}

// ==========================
// Writes g_memory back to disk.
// ==========================
static void saveMemory()
{
    QFile f(memoryFilePath());
    if (!f.open(QIODevice::WriteOnly | QIODevice::Truncate))
        return;

    QJsonDocument doc(g_memory);
    f.write(doc.toJson(QJsonDocument::Compact));
}

// ========================================================
// Memory Lookup Helpers
// ========================================================

// true if Spanish fragment already saved
static bool isKnownSpanish(const QString &es)
{
    QString esNorm = es.trimmed().toLower();

    for (const QJsonValue &v : g_memory)
    {
        QJsonObject o = v.toObject();
        QString storedEs = o.value("Spanish").toString().trimmed().toLower();

        if (storedEs == esNorm)
            return true;
    }
    return false;
}

// returns saved English translation if known.
static QString lookupEnglish(const QString &es)
{
    QString esNorm = es.trimmed().toLower();

    for (const QJsonValue &v : g_memory)
    {
        QJsonObject o = v.toObject();
        QString storedEs = o.value("Spanish").toString().trimmed().toLower();

        if (storedEs == esNorm)
            return o.value("English").toString();
    }
    return QString();
}

// saves or updates a Spanish‚ÜíEnglish pair.
static void addToMemory(const QString &es, const QString &en)
{
    QString esNorm = es.trimmed().toLower();
    QString enNorm = en.trimmed();

    // Update existing
    for (int i = 0; i < g_memory.size(); ++i)
    {
        QJsonObject o = g_memory[i].toObject();
        QString storedEs = o.value("Spanish").toString().trimmed().toLower();

        if (storedEs == esNorm)
        {
            o["English"] = enNorm;
            g_memory[i] = o;
            return;
        }
    }

    // Otherwise add new
    QJsonObject o;
    o["Spanish"] = esNorm;
    o["English"] = enNorm;
    g_memory.append(o);
}

// ==========================
// Applies background color (used for green/red/yellow feedback).
// ==========================
// Sets a widget's background color by appending a CSS rule to its
// existing stylesheet. Used to mark text fields as correct (green),
// incorrect (red), or new (yellow) during practice.

static void colorWidget(QWidget *w, const QColor &c)
{
    if (!w) return;
    QString cur = w->styleSheet();
    cur += QString("background-color:%1;").arg(c.name());
    w->setStyleSheet(cur);
}

// =======================================
// Reconstructs full sentences by concatenating table fragments.
// =======================================
static void rebuildFullSentences(Ui::MainWindow *ui)
{
    if (!ui) return;

    QStringList esPieces;
    QStringList enPieces;

    int rows = ui->tableSentence->rowCount();

    for (int r = 0; r < rows; ++r)
    {
        auto *esEdit = qobject_cast<QTextEdit*>(
            ui->tableSentence->cellWidget(r, COL_ES));
        auto *enEdit = qobject_cast<QTextEdit*>(
            ui->tableSentence->cellWidget(r, COL_EN));

        if (!esEdit || !enEdit) continue;

        QString es = esEdit->toPlainText().trimmed();
        QString en = enEdit->toPlainText().trimmed();

        if (!es.isEmpty()) esPieces << es;
        if (!en.isEmpty()) enPieces << en;
    }

    ui->txtSpanishFull->setPlainText(esPieces.join(" "));
    ui->txtEnglishFull->setPlainText(enPieces.join(" "));

}

// =======================================
// Creates bullet list of memory entries for random sentence generation.
// =======================================
static QString buildMemoryListForPrompt()
{
    QStringList lines;

    for (const QJsonValue &v : g_memory)
    {
        QJsonObject o = v.toObject();
        QString es = o.value("Spanish").toString().trimmed();
        QString en = o.value("English").toString().trimmed();

        if (es.isEmpty()) continue;

        if (en.isEmpty())
            lines << QString("- \"%1\"").arg(es);
        else
            lines << QString("- \"%1\" = \"%2\"").arg(es, en);
    }

    return lines.join("\n");
}

QString lightTheme = R"(

/* =======================================
   Light Theme
   ======================================= */

QWidget {
    background: #f4f4ff;
    color: #202020;
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
}

/* Inputs */
QLineEdit, QTextEdit {
    background: #ffffff;
    border: 2px solid #cccccc;
    border-radius: 10px;
    padding: 8px 10px;
    color: #202020;
}

/* Buttons */
QPushButton {
    background: #e0e0e0;
    color: #202020;
    border: 2px solid #888;
    border-radius: 12px;
    padding: 8px 14px;
    font-weight: 600;
}
QPushButton:hover {
    background: #ffffff;
    border-color: #444;
}

/* HOME BACKGROUND */
QWidget#pageHome {
    background-image: url(:/images/images/home_light.png);
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
}

/* TRANSLATE BACKGROUND */
QWidget#pageTranslate {
    background-image: url(:/images/images/translate_light.png);
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
}

/* APP NAME */
QLabel#lblAppName {
    font-size: 72px;
    font-weight: 900;
    color: #7a0099;
    letter-spacing: 2px;
    padding: 12px;
    background-color: transparent;
    text-shadow:
        0 0 8px #ff99ff,
        0 0 18px #cc66ff;
    margin-top: 10px;
}

/* START BUTTON */
#btnStart {
    margin-top: 20px;
}

/* TABLE TRANSPARENCY */
QTableWidget#tableSentence {
    background: transparent;
    border: none;
}
/* Make top-left corner transparent */
QTableCornerButton::section {
    background: transparent;
    border: none;
}

/* Make row-number column transparent */
QTableWidget#tableSentence QHeaderView::section {
    background: transparent !important;
    color: transparent;
    border: none;
}

QGroupBox#groupGrid {
    background: transparent;
    border: none;
}

QTableWidget::viewport {
    background: transparent;
}
QHeaderView::section {
    background-color: rgba(255,255,255,0.15);
    border: none;
}
QTableWidget::item {
    background-color: rgba(255,255,255,0.85);
}
QTableWidget::item {
    background-color: rgba(255,255,255,0.85);
}



)";   // END OF LIGHT THEME



QString darkTheme = R"(

/* =======================================
   Dark Theme
   ======================================= */

QWidget {
    font-family: 'Roboto', 'Segoe UI', sans-serif;
    font-size: 14px;
    background: #22222A;
    color: #d4d4ff;
}

/* Labels */
QLabel {
    color: #9b9bff;
}

/* Inputs */
QLineEdit, QTextEdit {
    background: #0e0e16;
    border: 2px solid #222244;
    border-radius: 10px;
    padding: 8px 10px;
    color: #e0e0ff;
}

/* Buttons */
QPushButton {
    background: #1a0033;
    color: #eaeaff;
    padding: 10px 18px;
    border-radius: 14px;
    font-weight: 600;
    border: 2px solid #6a00ff;
    box-shadow: 0 0 8px #6a00ff, inset 0 0 6px rgba(255,255,255,0.1);
}
QPushButton:hover {
    background: #2a0055;
    border-color: #ff00ff;
    box-shadow: 0 0 14px #ff00ff, inset 0 0 8px rgba(255,255,255,0.15);
}

/* HOME PAGE BACKGROUND */
QWidget#pageHome {
    background-image: url(:/images/images/home_dark.png);
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
}

/* TRANSLATE PAGE BACKGROUND */
QWidget#pageTranslate {
    background-image: url(:/images/images/translate_dark.png);
    background-repeat: no-repeat;
    background-position: center;
    background-size: cover;
}

/* APP NAME */
QLabel#lblAppName {
    font-size: 72px;
    font-weight: 900;
    color: #bf80ff;
    background-color: transparent;
    letter-spacing: 2px;
    padding: 16px;
    text-shadow:
        0 0 8px #ff00ff,
        0 0 16px #cc00ff,
        0 0 24px #aa00ff;
    margin-top: 10px;
}

/* START BUTTON */
#btnStart {
    margin-top: 20px;
}

/* TABLE TRANSPARENCY */
QTableWidget#tableSentence {
    background: transparent;
    border: none;
}
/* Make top-left corner transparent */
QTableCornerButton::section {
    background: transparent;
    border: none;
}

/* Make row-number column transparent */
QTableWidget#tableSentence QHeaderView::section {
    background: transparent !important;
    color: transparent;
    border: none;
}

QGroupBox#groupGrid {
    background: transparent;
    border: none;
}

QTableWidget::viewport {
    background: transparent;
}
QHeaderView::section {
    background-color: rgba(0,0,0,0.2);
    border: none;
}
QTableWidget::item {
    background-color: rgba(0,0,0,0.55);
}
QTableWidget::item {
    background-color: rgba(0,0,0,0.55);
}


)";  // END OF DARK THEME


// ==========================
// MainWindow constructor
// ==========================

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent),
      ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    // ---- Remove groupGrid frame + margins so table is flush and transparent ----
    ui->groupGrid->setStyleSheet("background: transparent; border: none;");
    ui->groupGrid->setContentsMargins(0, 0, 0, 0);
    if (ui->groupGrid->layout()) {
        ui->groupGrid->layout()->setContentsMargins(0, 0, 0, 0);
        ui->groupGrid->layout()->setSpacing(0);
    }


    ui->lblAppName->setMinimumHeight(200);            // permanent height
    ui->lblAppName->setAlignment(Qt::AlignLeft);      // permanent alignment
    ui->lblAppName->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

    ui->lblAppName->setMinimumWidth(400);   // wider title

    ui->btnStart->setMinimumHeight(60);     // taller button


    // ============================================

    // ===== HOME PAGE NAVIGATION =====
    connect(ui->btnStart, &QPushButton::clicked, this, [=]() {
        ui->stackMain->setCurrentWidget(ui->pageTranslate);
    });


    // ==========================
    // Loads dark mode first, configures theme toggle button.
    // ==========================
    bool darkMode = true;   // start in dark mode
    ui->centralwidget->setStyleSheet(darkTheme);
    ui->lblAppName->setAlignment(Qt::AlignLeft | Qt::AlignTop);
    ui->btnStart->setStyleSheet("qproperty-alignment: 'AlignLeft | Qt::AlignTop';");
    // ---- Table transparency setup (initial load) ----
    ui->tableSentence->setStyleSheet(
        "QTableWidget { background: transparent; }"
        "QTableWidget::viewport { background: transparent; }"
        "QHeaderView::section { background-color: transparent; }"
    );



    // Always apply green audio style to full-sentence audio button at startup
    {
        QString fsStyle;
        if (darkMode)
            fsStyle = "font-weight:bold; color:#88ff88; background:#002200; border:1px solid #44aa44; border-radius:8px;";
        else
            fsStyle = "font-weight:bold; color:#005500; background:#d8ffd8; border:1px solid #55aa55; border-radius:8px;";

        ui->btnPlayFullSpanish->setStyleSheet(fsStyle);
    }

    connect(ui->btnTheme, &QPushButton::clicked, this, [=]() mutable {
        darkMode = !darkMode;

        if (darkMode)
        {
            ui->centralwidget->setStyleSheet(darkTheme);
            ui->btnTheme->setText("üåì");
        }
        else
        {
            ui->centralwidget->setStyleSheet(lightTheme);
            ui->btnTheme->setText("üåï");
        }

        // SAME alignment both themes
        ui->lblAppName->setAlignment(Qt::AlignLeft | Qt::AlignTop);
        ui->btnStart->setStyleSheet("qproperty-alignment: 'AlignLeft | AlignTop';");
        ui->tableSentence->setStyleSheet(
            "QTableWidget { background: transparent; }"
            "QTableWidget::viewport { background: transparent; }"
            "QHeaderView::section { background-color: transparent; }"
        );



    });

    // ==========================
    // Enables drag/drop reordering, stretch columns, custom header labels.
    // ==========================
    ui->tableSentence->setColumnCount(4);

    QStringList headers;
    headers << "Spanish" << "English" << "" << "";
    ui->tableSentence->setHorizontalHeaderLabels(headers);

    QHeaderView *H = ui->tableSentence->horizontalHeader();
    H->setSectionResizeMode(COL_ES,     QHeaderView::Stretch);
    H->setSectionResizeMode(COL_EN,     QHeaderView::Stretch);
    H->setSectionResizeMode(COL_DELETE, QHeaderView::ResizeToContents);
    H->setSectionResizeMode(COL_AUDIO, QHeaderView::ResizeToContents);

    ui->tableSentence->verticalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

    // Drag-and-drop rows
    ui->tableSentence->setSelectionBehavior(QAbstractItemView::SelectRows);
    ui->tableSentence->setDragDropMode(QAbstractItemView::InternalMove);
    ui->tableSentence->setDragEnabled(true);
    ui->tableSentence->setAcceptDrops(true);
    ui->tableSentence->setDropIndicatorShown(true);

    ui->tableSentence->setVisible(false);

    // ===============
    // Text explaining workflow: Add ‚Üí AI split ‚Üí Submit.
    // ===============
    ui->lblInstructions->setText(
        "1. Enter a sentence in Spanish.\n"
        "2. Click Add.\n"
        "3. The sentence will be split into grammatical elements (Spanish / English).\n"
        "4. You can edit, delete, or add rows.\n"
        "5. Click Submit to save elements to memory.\n"
        "   Known elements: English is hidden so you can recall it.\n"
        "   New elements: both Spanish and English are saved.\n"
    );

    ui->lblInstructions->setStyleSheet(
        "font-size: 14px;"
        "color: #ddddff;"
        "background:#25253a;"
        "border:1px solid #444466;"
        "border-radius: 6px;"
        "padding:10px;"
    );

    // ===============
    // Calls loadMemory().
    // ===============
    loadMemory();
    // ==============================================
    // Example usage of inheritance (non-intrusive)
    // Wraps g_memory entries into MemoryItem objects
    // ==============================================
    QVector<MemoryItem> inheritedMemory;

    for (const QJsonValue &v : g_memory)
    {
        QJsonObject o = v.toObject();
        QString es = o.value("Spanish").toString();
        QString en = o.value("English").toString();

        bool known = !en.trimmed().isEmpty();  // simple rule for demo purposes
        inheritedMemory.append(MemoryItem(es, en, known));
    }



    // =========================
    // Creates books folder and loads book list.
    // =========================
    booksDir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation)
               + "/books";
    QDir().mkpath(booksDir);

    // Load list of books
    loadBooksList();

    // =========================
    // Spanish placeholder in English, English placeholder normally.
    // =========================

    // Placeholders ‚Äî Spanish placeholder in English
    ui->txtSpanishFull->setPlaceholderText("Enter a Spanish sentence here");
    ui->txtEnglishFull->setPlaceholderText("English translation");

    // =========================
    // Initialize network manager
    // =========================
    networkManager = new QNetworkAccessManager(this);

    // ======================
    // ADD ROW (AI-Generated Split). Trigger: btnAddRow clicked
    // ======================
    connect(ui->btnAddRow, &QPushButton::clicked, this, [=]() {

        QString es = ui->txtSpanishFull->toPlainText().trimmed();
        QString en = ui->txtEnglishFull->toPlainText().trimmed();

        // In EN‚ÜíSP mode, Spanish is intentionally empty.
        // Only require Spanish sentence when NOT in English‚ÜíSpanish mode.
        if (!englishToSpanishMode && es.isEmpty())
        {
            QMessageBox::warning(this, "Missing", "Enter a Spanish sentence first.");
            return;
        }


        // Template we want from AI
        QString jsonTemplate =
            "{\n"
            "  \"FullEnglish\": \"...\",\n"
            "  \"Elements\": [\n"
            "    { \"Spanish\": \"...\", \"English\": \"...\" }\n"
            "  ]\n"
            "}";


        QString sentenceForAI = englishToSpanishMode ? en : es;

        // Build correct prompt depending on mode
        QString prompt;

        if (englishToSpanishMode)
        {
            // EN ‚Üí SP mode
            prompt = QString(
                "You are a Spanish‚ÄìEnglish grammar processor.\n"
                "Given the ENGLISH sentence below, translate it into Spanish,\n"
                "then produce strictly this JSON format:\n"
                "{\n"
                "  \"FullEnglish\": \"...\",\n"
                "  \"Elements\": [\n"
                "    { \"Spanish\": \"...\", \"English\": \"...\" }\n"
                "  ]\n"
                "}\n"
                "\n"
                "RULES:\n"
                "  ‚Ä¢ First translate the full English sentence into natural Spanish.\n"
                "  ‚Ä¢ Split BOTH languages into matching grammatical elements.\n"
                "  ‚Ä¢ Spanish elements must be contiguous substrings of the Spanish translation.\n"
                "  ‚Ä¢ English elements must be contiguous substrings of the original English sentence.\n"
                "  ‚Ä¢ NO explanations.\n"
                "  ‚Ä¢ NO markdown.\n"
                "  ‚Ä¢ Output ONLY valid JSON.\n"
                "\n"
                "English sentence: \"%1\"\n"
            ).arg(sentenceForAI);
        }
        else
        {
            // SP ‚Üí EN mode (unchanged)
            prompt = QString(
                "You are a Spanish‚ÄìEnglish grammar processor.\n"
                "Given the SPANISH sentence below, produce strictly this JSON format:\n"
                "{\n"
                "  \"FullEnglish\": \"...\",\n"
                "  \"Elements\": [\n"
                "    { \"Spanish\": \"...\", \"English\": \"...\" }\n"
                "  ]\n"
                "}\n"
                "\n"
                "RULES:\n"
                "  ‚Ä¢ FullEnglish must be one complete natural English translation.\n"
                "  ‚Ä¢ Split both languages into matching grammatical elements.\n"
                "  ‚Ä¢ Spanish must be contiguous substrings.\n"
                "  ‚Ä¢ English must be contiguous substrings of the translation.\n"
                "  ‚Ä¢ NO explanations.\n"
                "  ‚Ä¢ NO markdown.\n"
                "  ‚Ä¢ Output ONLY valid JSON.\n"
                "\n"
                "Spanish sentence: \"%1\"\n"
            ).arg(sentenceForAI);
        }



        // ---- OpenAI API call ----
        QJsonObject reqJson;
        reqJson["model"] = "gpt-4.1-mini";
        reqJson["input"] = prompt;

        QNetworkRequest req(QUrl("https://api.openai.com/v1/responses"));
        req.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
        req.setRawHeader("Authorization",
                         "Bearer YOUR_KEY");

        QNetworkReply *reply =
            networkManager->post(req, QJsonDocument(reqJson).toJson());

        // Handle response
        connect(reply, &QNetworkReply::finished, this, [=]() {

            if (reply->error() != QNetworkReply::NoError)
            {
                QMessageBox::critical(this, "Network Error", reply->errorString());
                reply->deleteLater();
                return;
            }

            QString raw = reply->readAll();
            QJsonDocument outerDoc = QJsonDocument::fromJson(raw.toUtf8());
            if (!outerDoc.isObject())
            {
                QMessageBox::warning(this, "AI Error", "Invalid JSON from API:\n" + raw);
                reply->deleteLater();
                return;
            }

            QJsonObject root = outerDoc.object();
            QString content;

            // Try both possible shapes
            if (root.contains("output_text"))
            {
                content = root.value("output_text").toString();
            }
            else
            {
                QJsonArray outArr = root.value("output").toArray();
                if (!outArr.isEmpty())
                {
                    QJsonObject item = outArr[0].toObject();
                    QJsonArray contArr = item.value("content").toArray();
                    if (!contArr.isEmpty())
                    {
                        content = contArr[0].toObject().value("text").toString();
                    }
                }
            }

            if (content.isEmpty())
            {
                QMessageBox::warning(this, "AI Error", "Empty response:\n" + raw);
                reply->deleteLater();
                return;
            }

            QString cleaned = content.trimmed();
            cleaned.remove("```json");
            cleaned.remove("```");

            QJsonObject jsonObj;

            try
            {
                QJsonParseError err;
                QJsonDocument parsed = QJsonDocument::fromJson(cleaned.toUtf8(), &err);

                if (err.error != QJsonParseError::NoError)
                    throw std::runtime_error("Invalid JSON returned by AI");

                if (!parsed.isObject())
                    throw std::runtime_error("Expected JSON object");

                jsonObj = parsed.object();
            }
            catch (const std::exception &e)
            {
                QMessageBox::warning(
                    this,
                    "AI Parse Error",
                    QString("Failed to parse AI response:\n%1").arg(e.what())
                );

                reply->deleteLater();
                return;
            }


            QString fullEnglish = jsonObj.value("FullEnglish").toString().trimmed();



            QJsonArray elems = jsonObj.value("Elements").toArray();
            // In EN‚ÜíSP mode, DO NOT clear bottom sentence ‚Äî user must still see it.
            // Only clear English in SP‚ÜíEN mode.
            if (!englishToSpanishMode)
                ui->txtEnglishFull->clear();


            if (elems.isEmpty())
            {
                QMessageBox::warning(this, "AI Error", "No Elements returned.");
                reply->deleteLater();
                return;
            }

            // Fill table
            ui->tableSentence->setRowCount(0);
            ui->tableSentence->setVisible(true);

            for (int i = 0; i < elems.size(); ++i)
            {
                QJsonObject e = elems[i].toObject();

                QString esRaw = e.value("Spanish").toString().trimmed();
                QString enRaw = e.value("English").toString().trimmed();

                if (esRaw.isEmpty())
                    continue;

                // Determine if this Spanish element was seen before
                bool known = isKnownSpanish(esRaw);

                // Correct English: prefer memory if present; otherwise AI's value
                QString correctEn = lookupEnglish(esRaw);
                if (correctEn.trimmed().isEmpty())
                    correctEn = enRaw;

                QString correctEs = esRaw;

                // UI display logic:
                //   Known element: show Spanish, hide English (user must recall)
                //   New element: show both Spanish + English
                QString esShown, enShown;

                if (!englishToSpanishMode)
                {
                    // Normal SP ‚Üí EN practice
                    esShown = correctEs;
                    enShown = known ? "" : correctEn;
                }
                else
                {
                    // EN ‚Üí SP practice
                    esShown = "";          // Spanish must be entered by user
                    enShown = correctEn;   // Show English fragment
                }


                int row = ui->tableSentence->rowCount();
                ui->tableSentence->insertRow(row);

                // Spanish cell
                QTextEdit *esEdit = new QTextEdit(esShown);
                esEdit->setWordWrapMode(QTextOption::WordWrap);
                esEdit->setFixedHeight(40);   // <<‚Äî INCREASED HEIGHT
                esEdit->setStyleSheet("color:#111111;");
                esEdit->setAcceptRichText(false);
                esEdit->document()->setDefaultFont(QFont("Sans Serif"));


                // English cell
                QTextEdit *enEdit = new QTextEdit(enShown);
                enEdit->setWordWrapMode(QTextOption::WordWrap);
                enEdit->setLineWrapMode(QTextEdit::WidgetWidth);
                enEdit->setFixedHeight(40);    // <<‚Äî REDUCED HEIGHT
                enEdit->setStyleSheet("color:#111111;");
                enEdit->setAcceptRichText(false);
                enEdit->document()->setDefaultFont(QFont("Sans Serif"));



                // Store "model" values & meta
                esEdit->setProperty("correct", correctEs);
                enEdit->setProperty("correct", correctEn);
                esEdit->setProperty("order", i);
                enEdit->setProperty("order", i);
                esEdit->setProperty("known", known);
                enEdit->setProperty("known", known);

                ui->tableSentence->setCellWidget(row, COL_ES, esEdit);
                ui->tableSentence->setCellWidget(row, COL_EN, enEdit);

                // Per-row delete button
                QPushButton *delBtn = new QPushButton("X");
                delBtn->setFixedWidth(48);
                delBtn->setFixedHeight(48);

                delBtn->setToolTip("Delete this row");
                // ===========================
                // Audio button for Spanish
                // ===========================
                QPushButton *audioBtn = new QPushButton("üîä");
                audioBtn->setFixedWidth(48);
                audioBtn->setFixedHeight(48);

                audioBtn->setToolTip("Play Spanish audio");
                // Auto style based on current theme
                QString btnStyle;
                if (darkMode)
                    btnStyle = "font-weight:bold; color:#88ff88; background:#002200; border:1px solid #44aa44; border-radius:8px;";
                else
                    btnStyle = "font-weight:bold; color:#005500; background:#d8ffd8; border:1px solid #55aa55; border-radius:8px;";

                audioBtn->setStyleSheet(btnStyle);

                ui->tableSentence->setCellWidget(row, COL_AUDIO, audioBtn);

                connect(audioBtn, &QPushButton::clicked, this, [=]() {
                    QString sp = esEdit->toPlainText().trimmed();
                    if (!sp.isEmpty())
                        playSpanishAudio(sp);

                });

                QString delStyle;
                if (darkMode)
                    delStyle = "font-weight:bold; color:#ff8888; background:#330000; border:1px solid #aa4444; border-radius:8px;";
                else
                    delStyle = "font-weight:bold; color:#aa0000; background:#ffe5e5; border:1px solid #cc6666; border-radius:8px;";

                delBtn->setStyleSheet(delStyle);

                ui->tableSentence->setCellWidget(row, COL_DELETE, delBtn);
                ui->tableSentence->setRowHeight(row, 32);


                connect(delBtn, &QPushButton::clicked, this, [=]() {
                    int r = ui->tableSentence->indexAt(delBtn->pos()).row();
                    if (r >= 0)
                        ui->tableSentence->removeRow(r);
                });

                QColor yellow("#fff3b0");
                if (!known)
                {
                    colorWidget(esEdit, yellow);
                    colorWidget(enEdit, yellow);
                }
                else
                {
                    colorWidget(esEdit, QColor(Qt::white));
                    colorWidget(enEdit, QColor(Qt::white));
                }
            }

            ui->tableSentence->resizeColumnsToContents();
            ui->tableSentence->resizeRowsToContents();
            // ALWAYS stretch Spanish/English columns even before theme switch
            ui->tableSentence->horizontalHeader()->setSectionResizeMode(COL_ES, QHeaderView::Stretch);
            ui->tableSentence->horizontalHeader()->setSectionResizeMode(COL_EN, QHeaderView::Stretch);

            reply->deleteLater();
        });
    });

    // ======================
    // ADD MANUAL ROW. Trigger: btnAddManualRow clicked
    // ======================
    connect(ui->btnAddManualRow, &QPushButton::clicked, this, [=]() {

        ui->tableSentence->setVisible(true);

        int row = ui->tableSentence->rowCount();
        ui->tableSentence->insertRow(row);

        // Editable Spanish
        QTextEdit *esEdit = new QTextEdit();
        esEdit->setWordWrapMode(QTextOption::WordWrap);
        esEdit->setFixedHeight(40);   // match AI rows
        esEdit->setStyleSheet("color:#111111;");
        esEdit->setAcceptRichText(false);
        esEdit->document()->setDefaultFont(QFont("Sans Serif"));


        // Editable English
        QTextEdit *enEdit = new QTextEdit();
        enEdit->setWordWrapMode(QTextOption::WordWrap);
        enEdit->setLineWrapMode(QTextEdit::WidgetWidth);
        enEdit->setFixedHeight(40);  // match Spanish
        enEdit->setStyleSheet("color:#111111;");
        enEdit->setAcceptRichText(false);
        enEdit->document()->setDefaultFont(QFont("Sans Serif"));



        // Mark as new/unknown
        esEdit->setProperty("correct", QString());  // will be set on submit
        enEdit->setProperty("correct", QString());
        esEdit->setProperty("order", row);
        enEdit->setProperty("order", row);
        esEdit->setProperty("known", false);
        enEdit->setProperty("known", false);

        QColor yellow("#fff3b0");
        colorWidget(esEdit, yellow);
        colorWidget(enEdit, yellow);

        ui->tableSentence->setCellWidget(row, COL_ES, esEdit);
        ui->tableSentence->setCellWidget(row, COL_EN, enEdit);

        // Per-row delete button
        QPushButton *delBtn = new QPushButton("X");
        delBtn->setToolTip("Delete this row");
        delBtn->setFixedWidth(48);
        delBtn->setFixedHeight(48);

        // ===========================
        // Audio button for Spanish
        // ===========================
        QPushButton *audioBtn = new QPushButton("üîä");
        audioBtn->setFixedWidth(48);
        audioBtn->setFixedHeight(48);

        audioBtn->setToolTip("Play Spanish audio");
        // Auto style based on current theme
        QString btnStyle;
        if (darkMode)
            btnStyle = "font-weight:bold; color:#88ff88; background:#002200; border:1px solid #44aa44; border-radius:8px;";
        else
            btnStyle = "font-weight:bold; color:#005500; background:#d8ffd8; border:1px solid #55aa55; border-radius:8px;";

        audioBtn->setStyleSheet(btnStyle);

        ui->tableSentence->setCellWidget(row, COL_AUDIO, audioBtn);

        connect(audioBtn, &QPushButton::clicked, this, [=]() {
            QString sp = esEdit->toPlainText().trimmed();
            if (!sp.isEmpty())
                playSpanishAudio(sp);

        });

        QString delStyle;
        if (darkMode)
            delStyle = "font-weight:bold; color:#ff8888; background:#330000; border:1px solid #aa4444; border-radius:8px;";
        else
            delStyle = "font-weight:bold; color:#aa0000; background:#ffe5e5; border:1px solid #cc6666; border-radius:8px;";

        delBtn->setStyleSheet(delStyle);

        ui->tableSentence->setCellWidget(row, COL_DELETE, delBtn);
        ui->tableSentence->setRowHeight(row, 32);


        connect(delBtn, &QPushButton::clicked, this, [=]() {
            int r = ui->tableSentence->indexAt(delBtn->pos()).row();
            if (r >= 0)
                ui->tableSentence->removeRow(r);
        });
    });

    // ==========================
    // SUBMIT (Practice Checking + Save Memory). Trigger: btnSubmit clicked
    // ==========================
    connect(ui->btnSubmit, &QPushButton::clicked,
            this, &MainWindow::onSubmitClicked);
    // ==========================
    // PLAY FULL SPANISH SENTENCE
    // ==========================
    connect(ui->btnPlayFullSpanish, &QPushButton::clicked, this, [=]() {


        QString full = ui->txtSpanishFull->toPlainText().trimmed();
        if (!full.isEmpty())
            playSpanishAudio(full);
    });

    // ==========================
    // RANDOM SPANISH SENTENCE
    // ==========================
    // RANDOM SPANISH SENTENCE (Corrected version)
    // Creates NATURAL sentences using saved fragments
    // ==========================
    connect(ui->btnRandomSpanish, &QPushButton::clicked, this, [=]() {
        ui->txtEnglishFull->clear();

        englishToSpanishMode = false;

        if (g_memory.isEmpty())
        {
            QMessageBox::warning(this, "Not enough data",
                                 "You must save at least one element first.");
            return;
        }

        QString list = buildMemoryListForPrompt();

        QString jsonTemplate =
            "{\n"
            "  \"FullEnglish\": \"...\",\n"
            "  \"Elements\": [\n"
            "    { \"Spanish\": \"...\", \"English\": \"...\" }\n"
            "  ]\n"
            "}";



        // Minimal natural generator ‚Äî no ‚Äúuse as many words as possible‚Äù
        QString prompt = QString(
            "You are generating a NATURAL Spanish sentence using ONLY the following fragments:\n"
            "%1\n\n"
            "RULES:\n"
            "  ‚Ä¢ Use only the fragments ‚Äî but you do NOT need to use all of them.\n"
            "  ‚Ä¢ Choose whichever fragments form ONE natural, grammatically correct sentence.\n"
            "  ‚Ä¢ You MAY reorder fragments.\n"
            "  ‚Ä¢ You MAY add minimal connectors (y, pero, que, para, a, de).\n"
            "  ‚Ä¢ You may NOT invent new nouns or verbs.\n"
            "  ‚Ä¢ Output ONLY JSON:\n"
            "%2\n"
        ).arg(list, jsonTemplate);


        QJsonObject reqJson;
        reqJson["model"] = "gpt-4.1-mini";
        reqJson["input"] = prompt;

        QNetworkRequest req(QUrl("https://api.openai.com/v1/responses"));
        req.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
        req.setRawHeader("Authorization",
            "Bearer YOUR_KEY");

        QNetworkReply *reply =
            networkManager->post(req, QJsonDocument(reqJson).toJson());

        connect(reply, &QNetworkReply::finished, this, [=]() {

            if (reply->error() != QNetworkReply::NoError)
            {
                QMessageBox::critical(this, "Network Error", reply->errorString());
                reply->deleteLater();
                return;
            }

            QString raw = reply->readAll();
            QJsonDocument outerDoc = QJsonDocument::fromJson(raw.toUtf8());

            QString content;
            if (outerDoc.object().contains("output_text"))
                content = outerDoc.object().value("output_text").toString();
            else
            {
                QJsonArray arr = outerDoc.object().value("output").toArray();
                if (!arr.isEmpty())
                {
                    QJsonArray contArr = arr[0].toObject().value("content").toArray();
                    if (!contArr.isEmpty())
                        content = contArr[0].toObject().value("text").toString();
                }
            }

            if (content.isEmpty())
            {
                QMessageBox::warning(this, "AI Error", "Empty response.");
                reply->deleteLater();
                return;
            }

            QString cleaned = content.trimmed();
            cleaned.remove("```json");
            cleaned.remove("```");

            QJsonParseError err;
            QJsonDocument parsed = QJsonDocument::fromJson(cleaned.toUtf8(), &err);
            if (err.error != QJsonParseError::NoError)
            {
                QMessageBox::warning(this, "AI Parse Error", cleaned);
                reply->deleteLater();
                return;
            }

            QJsonObject obj = parsed.object();
            QJsonArray elems = obj.value("Elements").toArray();

            if (elems.isEmpty())
            {
                QMessageBox::warning(this, "AI Error", "No Elements returned.");
                reply->deleteLater();
                return;
            }

            QString sp, en;

            for (auto v : elems)
            {
                QJsonObject o = v.toObject();
                sp += o.value("Spanish").toString().trimmed() + " ";
                en += o.value("English").toString().trimmed() + " ";
            }

            sp = sp.trimmed();
            en = en.trimmed();

            ui->txtSpanishFull->setPlainText(sp);

            ui->tableSentence->setRowCount(0);
            ui->tableSentence->setVisible(false);

            reply->deleteLater();
        });
    });


    // ==========================
    // RANDOM ENGLISH SENTENCE
    // ==========================
    // Generates Spanish + English using saved fragments
    // ==========================
    connect(ui->btnRandomEnglish, &QPushButton::clicked, this, [=]() {
        ui->txtSpanishFull->clear();

        englishToSpanishMode = true;

        if (g_memory.isEmpty())
        {
            QMessageBox::warning(this, "Not enough data",
                                 "You must save at least one element first.");
            return;
        }

        QString list = buildMemoryListForPrompt();

        QString jsonTemplate =
            "{\n"
            "  \"FullEnglish\": \"...\",\n"
            "  \"Elements\": [\n"
            "    { \"Spanish\": \"...\", \"English\": \"...\" }\n"
            "  ]\n"
            "}";



        // Minimal natural generator ‚Äî no ‚Äúuse as many words as possible‚Äù
        QString prompt = QString(
            "You are generating a NATURAL Spanish sentence using ONLY the following fragments:\n"
            "%1\n\n"
            "RULES:\n"
            "  ‚Ä¢ Use only the fragments ‚Äî but you do NOT need to use all of them.\n"
            "  ‚Ä¢ Choose whichever fragments form ONE natural, grammatically correct sentence.\n"
            "  ‚Ä¢ You MAY reorder fragments.\n"
            "  ‚Ä¢ You MAY add minimal connectors (y, pero, que, para, a, de).\n"
            "  ‚Ä¢ You may NOT invent new nouns or verbs.\n"
            "  ‚Ä¢ Output ONLY JSON:\n"
            "%2\n"
        ).arg(list, jsonTemplate);


        QJsonObject reqJson;
        reqJson["model"] = "gpt-4.1-mini";
        reqJson["input"] = prompt;

        QNetworkRequest req(QUrl("https://api.openai.com/v1/responses"));
        req.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
        req.setRawHeader("Authorization",
            "Bearer YOUR_KEY");

        QNetworkReply *reply =
            networkManager->post(req, QJsonDocument(reqJson).toJson());

        connect(reply, &QNetworkReply::finished, this, [=]() {

            if (reply->error() != QNetworkReply::NoError)
            {
                QMessageBox::critical(this, "Network Error", reply->errorString());
                reply->deleteLater();
                return;
            }

            QString raw = reply->readAll();
            QJsonDocument outerDoc = QJsonDocument::fromJson(raw.toUtf8());

            QString content;
            if (outerDoc.object().contains("output_text"))
                content = outerDoc.object().value("output_text").toString();
            else
            {
                QJsonArray arr = outerDoc.object().value("output").toArray();
                if (!arr.isEmpty())
                {
                    QJsonArray contArr = arr[0].toObject().value("content").toArray();
                    if (!contArr.isEmpty())
                        content = contArr[0].toObject().value("text").toString();
                }
            }

            if (content.isEmpty())
            {
                QMessageBox::
                    warning(this, "AI Error", "Empty response.");
                reply->deleteLater();
                return;
            }

            QString cleaned = content.trimmed();
            cleaned.remove("```json");
            cleaned.remove("```");

            QJsonParseError err;
            QJsonDocument parsed = QJsonDocument::fromJson(cleaned.toUtf8(), &err);
            if (err.error != QJsonParseError::NoError)
            {
                QMessageBox::warning(this, "AI Parse Error", cleaned);
                reply->deleteLater();
                return;
            }

            QJsonObject obj = parsed.object();
            QJsonArray elems = obj.value("Elements").toArray();

            if (elems.isEmpty())
            {
                QMessageBox::warning(this, "AI Error", "No Elements returned.");
                reply->deleteLater();
                return;
            }

            QString sp, en;

            for (auto v : elems)
            {
                QJsonObject o = v.toObject();
                sp += o.value("Spanish").toString().trimmed() + " ";
                en += o.value("English").toString().trimmed() + " ";
            }

            sp = sp.trimmed();
            en = en.trimmed();

            // EN ‚Üí SP practice:
            // Show ONLY English (user must type Spanish)
            ui->txtSpanishFull->clear();
            ui->txtEnglishFull->setPlainText(en);
            ui->txtSpanishFull->clear();



            ui->tableSentence->setRowCount(0);
            ui->tableSentence->setVisible(false);

            reply->deleteLater();
        });
    });

    // When user chooses a book
    connect(ui->comboBooks, QOverload<int>::of(&QComboBox::activated),
            this, [=](int index)
    {
        QString t = ui->comboBooks->itemText(index);

        if (t == "‚ûï Add new book...")
        {
            // Create the book and get the name
            QString newBook = createNewBook();
            if (newBook.isEmpty()) return;

            // BLOCK SIGNALS so setting text does NOT re-trigger activated()
            QSignalBlocker blocker(ui->comboBooks);

            ui->comboBooks->setCurrentText(newBook);
            currentBook = newBook;

            return;
        }

        // Normal existing book selection
        currentBook = t;
    });

    //back home button
    connect(ui->btnBackHome, &QPushButton::clicked, this, [=]() {
        ui->stackMain->setCurrentWidget(ui->pageHome);

        ui->lblAppName->setAlignment(Qt::AlignLeft | Qt::AlignTop);
        ui->btnStart->setStyleSheet("qproperty-alignment: 'AlignLeft | AlignTop';");
    });



    // When clicking "Next ‚Üí"
    connect(ui->btnNextSentence, &QPushButton::clicked,
            this, &MainWindow::loadBookNextSentence);

    connect(ui->btnRestartBook, &QPushButton::clicked,
            this, &MainWindow::restartCurrentBook);

    connect(ui->btnDeleteBook, &QPushButton::clicked,
            this, &MainWindow::deleteCurrentBook);




    ui->stackMain->setCurrentWidget(ui->pageHome);
    // ==========================
    // INITIALIZE COUNTERS ON PAGE LOAD
    // ==========================
    ui->lblElementCount->setText(
        QString("Elements saved: %1").arg(g_memory.size())
    );

    int correct = 0;
    for (bool x : g_history)
        if (x) correct++;

    double percent = g_history.isEmpty()
        ? 0.0
        : (100.0 * correct / g_history.size());

    ui->lblAccuracy->setText(
        QString("Accuracy (last %1): %2%")
            .arg(g_history.size())
            .arg(QString::number(percent, 'f', 1))
    );


}

QString MainWindow::generateSentence(bool spanishMode)
{
    Q_UNUSED(spanishMode);
    return QString();
}

// ==========================
// onSubmitClicked  ‚Äî FIXED
// ==========================

void MainWindow::onSubmitClicked()
{
    if (!ui->tableSentence->isVisible() ||
        ui->tableSentence->rowCount() == 0)
    {
        QMessageBox::information(this, "No Elements", "Click Add first.");
        return;
    }

    int rows = ui->tableSentence->rowCount();

    // --------- Fix word order if user dragged rows ---------
    bool wrongOrder = false;
    for (int r = 0; r < rows; ++r)
    {
        auto *esEdit = qobject_cast<QTextEdit*>(
            ui->tableSentence->cellWidget(r, COL_ES));
        if (!esEdit) continue;

        if (esEdit->property("order").toInt() != r)
            wrongOrder = true;
    }

    if (wrongOrder)
    {
        struct Bundle {
            int order;
            QWidget *es;
            QWidget *en;
            QWidget *del;
        };

        QList<Bundle> blocks;

        for (int r = 0; r < rows; ++r)
        {
            auto *esEdit = qobject_cast<QTextEdit*>(
                ui->tableSentence->cellWidget(r, COL_ES));
            if (!esEdit) continue;

            Bundle b;
            b.order = esEdit->property("order").toInt();
            b.es    = esEdit;
            b.en    = ui->tableSentence->cellWidget(r, COL_EN);
            b.del   = ui->tableSentence->cellWidget(r, COL_DELETE);

            blocks.append(b);
        }

        std::sort(blocks.begin(), blocks.end(),
                  [](const Bundle &a, const Bundle &b) {
                      return a.order < b.order;
                  });

        ui->tableSentence->setRowCount(0);

        for (int i = 0; i < blocks.size(); ++i)
        {
            ui->tableSentence->insertRow(i);
            ui->tableSentence->setCellWidget(i, COL_ES,     blocks[i].es);
            ui->tableSentence->setCellWidget(i, COL_EN,     blocks[i].en);
            ui->tableSentence->setCellWidget(i, COL_DELETE, blocks[i].del);
        }

        QMessageBox::information(this, "Order fixed",
                                 "Element order fixed.");
    }

    rows = ui->tableSentence->rowCount();

    QColor green("#c8f7c5");
    QColor red("#f7c5c5");

    auto normalize = [](QString s){
        s = s.normalized(QString::NormalizationForm_KD);
        s.remove(QRegularExpression("[\\p{Mn}]"));
        return s.toLower().trimmed();
    };

    bool enToSp = englishToSpanishMode;

    // =========================
    // VALIDATION + MEMORY SAVE
    // =========================
    for (int r = 0; r < rows; ++r)
    {
        auto *esEdit = qobject_cast<QTextEdit*>(
            ui->tableSentence->cellWidget(r, COL_ES));
        auto *enEdit = qobject_cast<QTextEdit*>(
            ui->tableSentence->cellWidget(r, COL_EN));

        if (!esEdit || !enEdit)
            continue;

        QString correctEs = esEdit->property("correct").toString().trimmed();
        QString correctEn = enEdit->property("correct").toString().trimmed();

        QString userEs = esEdit->toPlainText().trimmed();
        QString userEn = enEdit->toPlainText().trimmed();

        if (enToSp)
        {
            // User must type SPANISH
            bool ok = (normalize(userEs) == normalize(correctEs));
            // ====== SAVE RESULT TO HISTORY ======
            g_history.append(ok);
            if (g_history.size() > 100)
                g_history.removeFirst();


            if (ok)
            {
                colorWidget(esEdit, green);
            }
            else
            {
                colorWidget(esEdit, red);
                esEdit->setPlainText(correctEs);   // corrected SPANISH
            }

            // English is always a clue ‚Üí always green
            colorWidget(enEdit, green);

            // DO NOT SAVE BLANK SPANISH
            if (!userEs.isEmpty())
                addToMemory(correctEs, correctEn);
        }
        else
        {
            // SP‚ÜíEN mode (normal)
            bool okES = (normalize(userEs) == normalize(correctEs));
            bool okEN = (normalize(userEn) == normalize(correctEn));
            // ====== SAVE EN correctness to history ======
            g_history.append(okEN);
            if (g_history.size() > 100)
                g_history.removeFirst();


            if (okES)
                colorWidget(esEdit, green);
            else
            {
                colorWidget(esEdit, red);
                esEdit->setPlainText(correctEs);
            }

            if (okEN)
                colorWidget(enEdit, green);
            else
            {
                colorWidget(enEdit, red);
                enEdit->setPlainText(correctEn);
            }

            addToMemory(correctEs, correctEn);
        }
    }

    // ========================
    // UPDATE ELEMENT COUNTER
    // ========================
    ui->lblElementCount->setText(
        QString("Elements saved: %1").arg(g_memory.size())
    );

    // ========================
    // UPDATE ACCURACY %
    // ========================
    int correct = 0;
    for (bool x : g_history)
        if (x) correct++;

    double percent = g_history.isEmpty()
        ? 0.0
        : (100.0 * correct / g_history.size());

    ui->lblAccuracy->setText(
        QString("Accuracy (last %1): %2%")
            .arg(g_history.size())
            .arg(QString::number(percent, 'f', 1))
    );

    saveMemory();

    // =========================
    // REBUILD FULL SENTENCES
    // =========================
    // NEVER rebuild in EN‚ÜíSP (breaks logic!)
    if (!enToSp)
    {
        rebuildFullSentences(ui);
    }

    // =========================
    // EN‚ÜíSP: BUILD SPANISH FULL SENTENCE MANUALLY
    // =========================
    if (enToSp)
    {
        QStringList sp;

        for (int r = 0; r < rows; ++r)
        {
            auto *esEdit = qobject_cast<QTextEdit*>(
                ui->tableSentence->cellWidget(r, COL_ES));
            if (!esEdit) continue;

            QString cleaned = esEdit->toPlainText().trimmed();
            if (!cleaned.isEmpty())
                sp << cleaned;
        }

        ui->txtSpanishFull->setPlainText(sp.join(" "));
        // English full sentence stays ‚Äî do not touch it.
    }
}


void MainWindow::playSpanishAudio(const QString &text)
{
    if (text.trimmed().isEmpty())
        return;

    QString q = QUrl::toPercentEncoding(text);

    QString url = QString(
        "https://translate.google.com/translate_tts"
        "?ie=UTF-8&client=tw-ob&tl=es&q=%1"
    ).arg(q);

    QNetworkRequest req{ QUrl(url) };
    req.setRawHeader("User-Agent", "Mozilla/5.0");

    QNetworkReply *reply = networkManager->get(req);

    connect(reply, &QNetworkReply::finished, this, [=]() {
        if (reply->error() != QNetworkReply::NoError) {
            QMessageBox::warning(this, "Audio Error", reply->errorString());
            reply->deleteLater();
            return;
        }

        QByteArray mp3 = reply->readAll();
        reply->deleteLater();

        QString tempPath = QStandardPaths::writableLocation(
            QStandardPaths::TempLocation
        ) + "/tts_audio.mp3";

        QFile f(tempPath);
        if (!f.open(QIODevice::WriteOnly)) {
            QMessageBox::warning(this, "Audio Error", "Cannot write temp file.");
            return;
        }
        f.write(mp3);
        f.close();

        QProcess::execute("mpg123", QStringList() << tempPath);
    });
}

void MainWindow::loadBooksList()
{
    ui->comboBooks->clear();

    QDir dir(booksDir);
    QStringList files = dir.entryList(QStringList() << "*.json", QDir::Files);

    for (const QString &f : files)
        ui->comboBooks->addItem(f.left(f.length() - 5));  // remove .json

    // Always add the special option at the end
    ui->comboBooks->addItem("‚ûï Add new book...");
}


// ===============================
// createNewBook()
// Splits TXT books into real sentences instead of lines
// ===============================
QString MainWindow::createNewBook()
{
    //
    // STEP 1 ‚Äî Ask user for TXT/JSON file
    //
    QString srcPath = QFileDialog::getOpenFileName(
        this,
        "Import Book File",
        QDir::homePath(),
        "Book Files (*.txt *.json)"
    );

    if (srcPath.isEmpty())
        return "";  // cancelled



    //
    // STEP 2 ‚Äî Ask user for book name
    //
    bool ok = false;
    QString name = QInputDialog::getText(
        this,
        "Name Your Book",
        "Enter book name:",
        QLineEdit::Normal,
        "",
        &ok
    );

    if (!ok || name.trimmed().isEmpty())
        return "";

    name = name.trimmed();
    QString dstPath = booksDir + "/" + name + ".json";

    if (QFile::exists(dstPath))
    {
        QMessageBox::warning(this, "Book Exists",
                             "A book with that name already exists.");
        return "";
    }



    //
    // STEP 3 ‚Äî Parse file into clean sentence list
    //
    QJsonArray sentences;


    // =========================================================
    // TXT IMPORT
    // Read the whole book, split into sentences properly
    // =========================================================
    if (srcPath.endsWith(".txt", Qt::CaseInsensitive))
    {
        QFile f(srcPath);
        QString whole;

        try
        {
            if (!f.open(QIODevice::ReadOnly | QIODevice::Text))
                throw std::runtime_error("Cannot open TXT file");

            whole = QString::fromUtf8(f.readAll());
            f.close();
        }
        catch (const std::exception &e)
        {
            QMessageBox::warning(
                this,
                "File Error",
                QString("File open failed:\n%1").arg(e.what())
            );
            return "";
        }

        whole.replace("\r", " ");
        whole.replace("\n", " ");

        whole = whole.trimmed();
        if (whole.isEmpty())
        {
            QMessageBox::warning(this, "Empty File",
                                 "The selected TXT file contains no text.");
            return "";
        }

        QRegularExpression re("(?<=[\\.\\?\\!])\\s+");
        QStringList list = whole.split(re, Qt::SkipEmptyParts);

        for (QString s : list)
        {
            s = s.trimmed();
            if (!s.isEmpty())
                sentences.append(s);
        }
    }


    // =========================================================
    // JSON IMPORT ‚Äî unchanged
    // =========================================================
    else if (srcPath.endsWith(".json", Qt::CaseInsensitive))
    {
        QFile f(srcPath);
        if (!f.open(QIODevice::ReadOnly))
        {
            QMessageBox::warning(this, "Error",
                                 "Cannot open the selected JSON file.");
            return "";
        }

        QJsonDocument d = QJsonDocument::fromJson(f.readAll());
        f.close();

        if (!d.isObject())
        {
            QMessageBox::warning(this, "Invalid JSON",
                                 "Book JSON must contain { \"sentences\": [...] }");
            return "";
        }

        QJsonObject obj = d.object();

        if (!obj.contains("sentences") || !obj["sentences"].isArray())
        {
            QMessageBox::warning(this, "Invalid Format",
                                 "JSON must contain:\n  { \"sentences\": [ ... ] }");
            return "";
        }

        QJsonArray arr = obj["sentences"].toArray();

        for (auto v : arr)
        {
            if (v.isString())
                sentences.append(v.toString().trimmed());
        }
    }



    //
    // STEP 4 ‚Äî Validate non-empty
    //
    if (sentences.isEmpty())
    {
        QMessageBox::warning(this, "Empty Book",
                             "No valid sentences found.");
        return "";
    }



    //
    // STEP 5 ‚Äî Write JSON book to internal storage
    //
    QJsonObject outObj;
    outObj["sentences"] = sentences;
    outObj["currentIndex"] = 0;

    QFile out(dstPath);
    if (!out.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        QMessageBox::warning(this, "Write Error",
                             "Could not create the new book file.");
        return "";
    }

    out.write(QJsonDocument(outObj).toJson());
    out.close();


    //
    // STEP 6 ‚Äî Refresh dropdown + confirm
    //
    loadBooksList();

    QMessageBox::information(this, "Book Imported",
                             "The book has been successfully imported.");

    return name;
}



void MainWindow::loadBookNextSentence()
{
    QString book = currentBook;

    if (book.isEmpty())
        return;

    QString path = booksDir + "/" + book + ".json";

    QFile f(path);
    if (!f.open(QIODevice::ReadOnly))
        return;

    QJsonDocument doc = QJsonDocument::fromJson(f.readAll());
    f.close();

    if (!doc.isObject())
    {
        QMessageBox::warning(this, "Invalid Book",
                             "Book file is not valid JSON.");
        return;
    }

    QJsonObject obj = doc.object();

    // Extract array
    QJsonArray sentences = obj["sentences"].toArray();
    int idx = obj["currentIndex"].toInt();

    if (idx >= sentences.size())
    {
        QMessageBox::information(this, "Completed",
                                 "You've finished all sentences in this book.");
        return;
    }



    //
    // PROPER SAFE EXTRACTION (fix)
    //
    QString sentence;

    if (sentences[idx].isString())
    {
        sentence = sentences[idx].toString().trimmed();
    }
    else if (sentences[idx].isObject())
    {
        // If structured books appear later: extract Spanish
        QJsonObject o = sentences[idx].toObject();
        sentence = o.value("Spanish").toString().trimmed();
    }
    else
    {
        sentence = "";
    }

    if (sentence.isEmpty())
    {
        QMessageBox::warning(this, "Invalid Entry",
                             "Sentence entry is empty or unreadable.");
        return;
    }



    //
    // DISPLAY: Spanish only (user types English)
    //
    ui->txtSpanishFull->setPlainText(sentence);
    ui->txtEnglishFull->clear();
    englishToSpanishMode = false;   // <-- FORCE SP‚ÜíEN mode for book sentences


    // Hide table until AI split or manual entry
    ui->tableSentence->setRowCount(0);
    ui->tableSentence->setVisible(false);



    //
    // Save new index + update book JSON
    //
    obj["currentIndex"] = idx + 1;

    QFile f2(path);
    if (!f2.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        QMessageBox::warning(this, "Write Error",
                             "Could not update book progress.");
        return;
    }

    f2.write(QJsonDocument(obj).toJson());
    f2.close();
}


void MainWindow::restartCurrentBook()
{
    QString book = ui->comboBooks->currentText();

    if (book.isEmpty() || book == "‚ûï Add new book...")
    {
        QMessageBox::warning(this, "No Book Selected",
                             "Please select a book first.");
        return;
    }

    // Confirm action
    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(
                this,
                "Restart Book",
                QString("Restart \"%1\" from the beginning?\n\n"
                        "This will reset your progress but keep all sentences.")
                    .arg(book),
                QMessageBox::Yes | QMessageBox::No
            );

    if (reply != QMessageBox::Yes)
        return;

    QString path = booksDir + "/" + book + ".json";
    QFile f(path);

    if (!f.open(QIODevice::ReadOnly))
    {
        QMessageBox::warning(this, "Error",
                             "Cannot open the selected book file.");
        return;
    }

    QJsonDocument doc = QJsonDocument::fromJson(f.readAll());
    f.close();

    if (!doc.isObject())
    {
        QMessageBox::warning(this, "Invalid Book",
                             "Book file is corrupt or invalid JSON.");
        return;
    }

    QJsonObject obj = doc.object();

    // Reset progress
    obj["currentIndex"] = 0;

    // Save updated file
    QFile f2(path);
    if (!f2.open(QIODevice::WriteOnly | QIODevice::Truncate))
    {
        QMessageBox::warning(this, "Write Error",
                             "Failed to update the book file.");
        return;
    }

    f2.write(QJsonDocument(obj).toJson());
    f2.close();

    QMessageBox::information(
        this,
        "Book Restarted",
        QString("\"%1\" has been restarted.\nYou are now at sentence 1.").arg(book)
    );
}

void MainWindow::deleteCurrentBook()
{
    QString book = ui->comboBooks->currentText();

    if (book.isEmpty() || book == "‚ûï Add new book...")
    {
        QMessageBox::warning(this, "No Book Selected",
                             "Please select a book to delete.");
        return;
    }

    // Confirm deletion
    QMessageBox::StandardButton reply;
    reply = QMessageBox::question(
                this,
                "Delete Book",
                QString("Are you sure you want to delete \"%1\"?\n\n"
                        "This cannot be undone.")
                    .arg(book),
                QMessageBox::Yes | QMessageBox::No
            );

    if (reply != QMessageBox::Yes)
        return;

    QString path = booksDir + "/" + book + ".json";

    if (!QFile::exists(path))
    {
        QMessageBox::warning(this, "Error",
                             "The book file does not exist.");
        return;
    }

    if (!QFile::remove(path))
    {
        QMessageBox::warning(this, "Error",
                             "Failed to delete the book file.");
        return;
    }

    // Reload dropdown
    loadBooksList();

    // Reset current book
    currentBook.clear();
    ui->comboBooks->setCurrentIndex(0);

    QMessageBox::information(
        this,
        "Book Deleted",
        QString("The book \"%1\" has been deleted.").arg(book)
    );

    // Clear UI that depended on book content
    ui->txtSpanishFull->clear();
    ui->txtEnglishFull->clear();
    ui->tableSentence->setRowCount(0);
    ui->tableSentence->setVisible(false);
}


MainWindow::~MainWindow()
{
    delete ui;
}
